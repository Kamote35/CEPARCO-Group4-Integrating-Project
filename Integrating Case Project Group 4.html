<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>µRISCV Assembler (Milestone 1)</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use Inter font -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Simple scrollbar styling */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        ::-webkit-scrollbar-thumb {
            background: #9ca3af; /* gray-400 */
            border-radius: 3px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* gray-500 */
        }
        ::-webkit-scrollbar-track {
            background: #1f2937; /* gray-800 */
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 min-h-screen p-4 md:p-8">

    <div class="max-w-7xl mx-auto">
        <!-- Header -->
        <header class="mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-cyan-400">µRISCV Pipeline Simulator</h1>
            <p class="text-lg text-gray-400">Milestone 1: Assembler & Opcode Generator</p>
        </header>

        <!-- Project Configuration Display -->
        <div class="mb-6 p-4 bg-gray-800 rounded-lg border border-gray-700">
            <h2 class="text-xl font-semibold mb-3 text-gray-100">Project Configuration</h2>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div>
                    <span class="text-sm font-medium text-cyan-400 block">Structural Hazard</span>
                    <span class="text-gray-200">Separate Memory</span>
                </div>
                <div>
                    <span class="text-sm font-medium text-cyan-400 block">Data Hazard</span>
                    <span class="text-gray-200">No Forwarding</span>
                </div>
                <div>
                    <span class="text-sm font-medium text-cyan-400 block">Control Hazard</span>
                    <span class="text-gray-200">Pipeline #2 (for Groups 3/4)</span>
                </div>
            </div>
            <p class="text-xs text-gray-500 mt-4 italic">Note: This tool only implements Milestone 1 (Assembly). The pipeline simulation logic is the next step.</p>
        </div>

        <!-- Main Content: Assembler -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            
            <!-- Left Panel: Input & Controls -->
            <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
                <h2 class="text-2xl font-semibold mb-4 text-gray-100">1. Assembly Input</h2>
                <p class="text-sm text-gray-400 mb-4">
                    Enter your µRISCV assembly code below. Program memory starts at <code class="bg-gray-700 text-cyan-300 px-2 py-0.5 rounded">0x0080</code>.
                    <br>Supported instructions: <code class="text-xs text-gray-500">LW, SW, ADD, SUB, ADDI, BEQ, BNE</code>
                    <br>Supported directive: <code class="text-xs text-gray-500">.word</code>
                </p>
                
                <textarea id="assemblyInput"
                    class="w-full h-96 p-4 bg-gray-900 border border-gray-700 rounded-md font-mono text-sm text-white resize-y focus:outline-none focus:ring-2 focus:ring-cyan-500"
                    placeholder=
"
Example program:
	
    addi x1, x6, 1
    beq x1, x5, loop # Example
    lw x2, 4(x3)
    sw x2, 0(sp)
    .word 0xCEDBAF
"></textarea>
                
                <button id="assembleButton" 
                    class="w-full mt-4 px-6 py-3 bg-cyan-600 text-white font-semibold rounded-lg shadow-md hover:bg-cyan-700 focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:ring-opacity-75 transition-all duration-200">
                    Assemble to Opcode
                </button>
            </div>

            <!-- Right Panel: Output & Errors -->
            <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
                <!-- Output Screen #1: Opcodes -->
                <h2 class="text-2xl font-semibold mb-4 text-gray-100">2. Output: Opcodes (Hex)</h2>
                <div id="outputContainer" class="w-full h-64 p-4 bg-gray-900 border border-gray-700 rounded-md font-mono text-sm text-white overflow-auto">
                    <pre id="opcodeOutput" class="whitespace-pre-wrap"></pre>
                </div>

                <!-- Output Screen #2: Error Messages -->
                <h2 class="text-2xl font-semibold mb-4 mt-6 text-gray-100">3. Output: Error Messages</h2>
                <div id="errorContainer" class="w-full h-32 p-4 bg-gray-900 border border-gray-700 rounded-md font-mono text-sm text-red-400 overflow-auto">
                    <pre id="errorOutput" class="whitespace-pre-wrap">No errors.</pre>
                </div>
            </div>

        </div>
    </div>

    <script>
        // --- CONSTANTS: RISC-V Definitions ---

        // Map register names to 5-bit binary strings
        const REG_MAP = {
            'x0': '00000', 'zero': '00000',
            'x1': '00001', 'ra': '00001',
            'x2': '00010', 'sp': '00010',
            'x3': '00011', 'gp': '00011',
            'x4': '00100', 'tp': '00100',
            'x5': '00101', 't0': '00101',
            'x6': '00110', 't1': '00110',
            'x7': '00111', 't2': '00111',
            'x8': '01000', 's0': '01000', 'fp': '01000',
            'x9': '01001', 's1': '01001',
            'x10': '01010', 'a0': '01010',
            'x11': '01011', 'a1': '01011',
            'x12': '01100', 'a2': '01100',
            'x13': '01101', 'a3': '01101',
            'x14': '01110', 'a4': '01110',
            'x15': '01111', 'a5': '01111',
            'x16': '10000', 'a6': '10000',
            'x17': '10001', 'a7': '10001',
            'x18': '10010', 's2': '10010',
            'x19': '10011', 's3': '10011',
            'x20': '10100', 's4': '10100',
            'x21': '10101', 's5': '10101',
            'x22': '10110', 's6': '10110',
            'x23': '10111', 's7': '10111',
            'x24': '11000', 's8': '11000',
            'x25': '11001', 's9': '11001',
            'x26': '11010', 's10': '11010',
            'x27': '11011', 's11': '11011',
            'x28': '11100', 't3': '11100',
            'x29': '11101', 't4': '11101',
            'x30': '11110', 't5': '11110',
            'x31': '11111', 't6': '11111',
        };

        // Instruction definitions: [type, opcode, funct3, funct7]
        const INSTR_MAP = {
            // R-Type: ADD, SUB, SLL, SLT, AND, OR
            'add':  ['R', '0110011', '000', '0000000'],
            'sub':  ['R', '0110011', '000', '0100000'],
            // 'sll':  ['R', '0110011', '001', '0000000'],
            // 'slt':  ['R', '0110011', '010', '0000000'],
            // 'and':  ['R', '0110011', '111', '0000000'],
            // 'or':   ['R', '0110011', '110', '0000000'],

            // I-Type (ALU): ADDI, SLLI, SLTI, ORI
            'addi': ['I', '0010011', '000'],
            // 'slli': ['I', '0010011', '001', '0000000'], // Special case: funct7 is '0000000'
            // 'slti': ['I', '0010011', '010'],
            // 'ori':  ['I', '0010011', '110'],

            // I-Type (Load): LW
            'lw':   ['L', '0000011', '010'], // L-type is just I-type with different operand parsing

            // S-Type (Store): SW
            'sw':   ['S', '0100011', '010'],

            // B-Type (Branch): BEQ, BNE, BLT, BGE
            'beq':  ['B', '1100011', '000'],
            'bne':  ['B', '1100011', '001'],
            // 'blt':  ['B', '1100011', '100'],
            // 'bge':  ['B', '1100011', '101'],
        };

        // --- DOM Elements ---
        const assembleButton = document.getElementById('assembleButton');
        const assemblyInput = document.getElementById('assemblyInput');
        const opcodeOutput = document.getElementById('opcodeOutput');
        const errorOutput = document.getElementById('errorOutput');

        // --- Event Listener ---
        assembleButton.addEventListener('click', assemble);

        // --- Helper Functions ---

        /**
         * Converts a decimal number to a binary string of a specific length,
         * handling two's complement for negative numbers.
         * @param {number} dec - The decimal number.
         * @param {number} bits - The desired bit length.
         * @returns {string} The binary string.
         */
        function toBinary(dec, bits) {
            let bin = (dec >>> 0).toString(2); // Unsigned right shift to handle 32-bits
            if (dec < 0) {
                // For negative numbers, get the two's complement
                bin = (Math.pow(2, bits) + dec).toString(2);
            }
            // Pad with leading zeros
            return bin.slice(-bits).padStart(bits, '0');
        }

        /**
         * Converts a binary string to a 32-bit hex string (e.g., "0x...").
         * @param {string} bin - The 32-bit binary string.
         * @returns {string} The 8-digit hex string with "0x" prefix.
         */
        function binToHex(bin) {
            const dec = parseInt(bin, 2) >>> 0; // Use unsigned shift for 32-bit
            return '0x' + dec.toString(16).toUpperCase().padStart(8, '0');
        }

        /**
         * Pads a hex string to a specific length.
         * @param {string} hex - The hex string (with or without "0x").
         * @param {number} len - The desired length (e.g., 8 for 32-bit).
         * @returns {string} The "0x" prefixed, zero-padded hex string.
         */
        function formatHex(hex, len = 8) {
            let value = hex.startsWith('0x') ? hex.substring(2) : hex;
            return '0x' + value.toUpperCase().padStart(len, '0');
        }

        /**
         * Reports an error to the UI.
         * @param {string} message - The error message.
         * @param {number} lineNum - The line number where the error occurred.
         * @returns {null} Always returns null to stop processing.
         */
        function reportError(message, lineNum) {
            errorOutput.textContent = `Error on line ${lineNum + 1}: ${message}\n`;
            return null;
        }

        /**
         * Parses R-Type instructions (e.g., add rd, rs1, rs2).
         * @param {Array<string>} parts - The instruction parts (e.g., ['add', 'x1', 'x2', 'x3']).
         * @param {Array<string>} def - The instruction definition from INSTR_MAP.
         * @returns {string|null} The 32-bit binary string or null on error.
         */
        function parseRType(parts, def) {
            const [_, funct7, funct3, opcode] = def;
            const rd = REG_MAP[parts[1]];
            const rs1 = REG_MAP[parts[2]];
            const rs2 = REG_MAP[parts[3]];
            
            if (!rd) return `Invalid destination register: ${parts[1]}`;
            if (!rs1) return `Invalid source register 1: ${parts[2]}`;
            if (!rs2) return `Invalid source register 2: ${parts[3]}`;

            return `${funct7}${rs2}${rs1}${funct3}${rd}${opcode}`;
        }

        /**
         * Parses I-Type ALU instructions (e.g., addi rd, rs1, imm).
         * @param {Array<string>} parts - The instruction parts (e.g., ['addi', 'x1', 'x2', '10']).
         * @param {Array<string>} def - The instruction definition from INSTR_MAP.
         * @param {string} instr - The instruction mnemonic (e.g., 'slli').
         * @returns {string|null} The 32-bit binary string or null on error.
         */
        function parseIType(parts, def, instr) {
            const [_, opcode, funct3] = def;
            const rd = REG_MAP[parts[1]];
            const rs1 = REG_MAP[parts[2]];
            const imm = parseInt(parts[3]);

            if (!rd) return `Invalid destination register: ${parts[1]}`;
            if (!rs1) return `Invalid source register 1: ${parts[2]}`;
            if (isNaN(imm)) return `Invalid immediate value: ${parts[3]}`;

            if (instr === 'slli') {
                // SLLI is a special I-type with funct7
                const shamt = toBinary(imm, 5); // 5-bit shift amount
                const funct7 = '0000000';
                return `${funct7}${shamt}${rs1}${funct3}${rd}${opcode}`;
            }

            if (imm < -2048 || imm > 2047) {
                return `Immediate value (${imm}) out of range for I-type (-2048 to 2047)`;
            }
            const imm_bin = toBinary(imm, 12);
            return `${imm_bin}${rs1}${funct3}${rd}${opcode}`;
        }
        
        /**
         * Parses Load instructions (e.g., lw rd, offset(rs1)).
         * @param {Array<string>} parts - The instruction parts (e.g., ['lw', 'x1', '4(x2)']).
         * @param {Array<string>} def - The instruction definition from INSTR_MAP.
         * @returns {string|null} The 32-bit binary string or null on error.
         */
        function parseLoadType(parts, def) {
            const [_, opcode, funct3] = def;
            const rd = REG_MAP[parts[1]];
            
            const memOperand = parts[2].match(/(-?\d+)\((x\d+|[a-z]+)\)/); // e.g., "4(x2)" or "-8(sp)"
            if (!memOperand) {
                return `Invalid load format. Expected 'lw rd, offset(rs1)', got: ${parts.slice(1).join(' ')}`;
            }

            const imm = parseInt(memOperand[1]);
            const rs1 = REG_MAP[memOperand[2]];

            if (!rd) return `Invalid destination register: ${parts[1]}`;
            if (!rs1) return `Invalid base register: ${memOperand[2]}`;
            if (isNaN(imm)) return `Invalid immediate offset: ${memOperand[1]}`;

            if (imm < -2048 || imm > 2047) {
                return `Immediate offset (${imm}) out of range for I-type (-2048 to 2047)`;
            }
            const imm_bin = toBinary(imm, 12);
            return `${imm_bin}${rs1}${funct3}${rd}${opcode}`;
        }

        /**
         * Parses S-Type (Store) instructions (e.g., sw rs2, offset(rs1)).
         * @param {Array<string>} parts - The instruction parts (e.g., ['sw', 'x1', '4(x2)']).
         * @param {Array<string>} def - The instruction definition from INSTR_MAP.
         * @returns {string|null} The 32-bit binary string or null on error.
         */
        function parseSType(parts, def) {
            const [_, opcode, funct3] = def;
            const rs2 = REG_MAP[parts[1]]; // Note: rs2 is the source register for SW
            
            const memOperand = parts[2].match(/(-?\d+)\((x\d+|[a-z]+)\)/); // e.g., "4(x2)"
            if (!memOperand) {
                return `Invalid store format. Expected 'sw rs2, offset(rs1)', got: ${parts.slice(1).join(' ')}`;
            }

            const imm = parseInt(memOperand[1]);
            const rs1 = REG_MAP[memOperand[2]];

            if (!rs2) return `Invalid source register: ${parts[1]}`;
            if (!rs1) return `Invalid base register: ${memOperand[2]}`;
            if (isNaN(imm)) return `Invalid immediate offset: ${memOperand[1]}`;

            if (imm < -2048 || imm > 2047) {
                return `Immediate offset (${imm}) out of range for S-type (-2048 to 2047)`;
            }

            const imm_bin = toBinary(imm, 12);
            const imm_11_5 = imm_bin.substring(0, 7);
            const imm_4_0 = imm_bin.substring(7);

            return `${imm_11_5}${rs2}${rs1}${funct3}${imm_4_0}${opcode}`;
        }

        /**
         * Parses B-Type (Branch) instructions (e.g., beq rs1, rs2, label).
         * @param {Array<string>} parts - The instruction parts (e.g., ['beq', 'x1', 'x2', 'loop']).
         * @param {Array<string>} def - The instruction definition from INSTR_MAP.
         * @param {Object} labelMap - The map of labels to addresses.
         * @param {number} currentAddr - The address of the current branch instruction.
         * @returns {string|null} The 32-bit binary string or null on error.
         */
        function parseBType(parts, def, labelMap, currentAddr) {
            const [_, opcode, funct3] = def;
            const rs1 = REG_MAP[parts[1]];
            const rs2 = REG_MAP[parts[2]];
            const label = parts[3];

            if (!rs1) return `Invalid source register 1: ${parts[1]}`;
            if (!rs2) return `Invalid source register 2: ${parts[2]}`;
            if (!labelMap.hasOwnProperty(label)) {
                return `Undefined label: ${label}`;
            }

            const labelAddr = labelMap[label];
            const offset = labelAddr - currentAddr;

            // B-type immediate is 13 bits, but bit 0 is always 0 and not stored.
            // Offset must be a multiple of 2.
            if (offset % 2 !== 0) {
                return `Branch offset is not even (target: ${formatHex(labelAddr, 4)}, current: ${formatHex(currentAddr, 4)})`;
            }

            if (offset < -4096 || offset > 4094) {
                return `Branch offset (${offset}) out of range for B-type (-4096 to 4094)`;
            }

            const imm_bin = toBinary(offset, 13); // 13-bit signed immediate
            
            // imm[12] | imm[10:5] | rs2 | rs1 | funct3 | imm[4:1] | imm[11] | opcode
            const imm_12 = imm_bin[0];
            const imm_11 = imm_bin[1];
            const imm_10_5 = imm_bin.substring(2, 8);
            const imm_4_1 = imm_bin.substring(8, 12);

            return `${imm_12}${imm_10_5}${rs2}${rs1}${funct3}${imm_4_1}${imm_11}${opcode}`;
        }


        // --- Main Assembler Logic ---

        function assemble() {
            const code = assemblyInput.value;
            const lines = code.split('\n');
            
            // Clear previous outputs
            opcodeOutput.textContent = '';
            errorOutput.textContent = 'No errors.';

            const labelMap = {};
            const programLines = [];
            let currentAddr = 0x80; // As per spec: Program memory starts at 0080
            let hasError = false;

            // --- First Pass: Build Label Map & clean lines ---
            for (let i = 0; i < lines.length; i++) {
                let line = lines[i].trim();
                
                // Remove comments
                const commentIndex = line.indexOf('#');
                if (commentIndex !== -1) {
                    line = line.substring(0, commentIndex).trim();
                }

                if (line.length === 0) continue; // Skip empty lines

                // Check for labels
                const labelIndex = line.indexOf(':');
                if (labelIndex !== -1) {
                    const label = line.substring(0, labelIndex).trim();
                    if (labelMap.hasOwnProperty(label)) {
                        reportError(`Duplicate label definition: ${label}`, i);
                        hasError = true;
                        break;
                    }
                    if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(label)) {
                        reportError(`Invalid label name: ${label}`, i);
                        hasError = true;
                        break;
                    }
                    labelMap[label] = currentAddr;
                    
                    // Remove label from line
                    line = line.substring(labelIndex + 1).trim();
                }

                // If there's code on the same line after a label, process it
                if (line.length > 0) {
                    programLines.push({ line, addr: currentAddr, lineNum: i });
                    currentAddr += 4; // All instructions and .word are 32-bit
                }
            }

            if (hasError) return;
            
            // --- Second Pass: Generate Opcodes ---
            let output = [];
            for (const { line, addr, lineNum } of programLines) {
                const parts = line.split(/[\s,()]+/); // Split by space, comma, or parens
                const instr = parts[0].toLowerCase();
                
                let binaryInstr = null;
                let errorMessage = null;

                if (instr === '.word') {
                    // Handle .word directive
                    if (parts.length !== 2) {
                        errorMessage = `'.word' directive expects exactly one argument.`;
                    } else {
                        let val = parts[1];
                        let numVal;
                        if (val.startsWith('0x')) {
                            numVal = parseInt(val.substring(2), 16);
                        } else {
                            numVal = parseInt(val);
                        }

                        if (isNaN(numVal)) {
                            errorMessage = `Invalid number for .word: ${parts[1]}`;
                        } else {
                            binaryInstr = toBinary(numVal, 32);
                        }
                    }
                } else {
                    // Handle instructions
                    const def = INSTR_MAP[instr];
                    if (!def) {
                        errorMessage = `Unknown instruction: ${instr}`;
                    } else {
                        const type = def[0];
                        const expectedArgs = (type === 'R') ? 4 : (type === 'B' ? 4 : (type === 'L' || type === 'S' ? 3 : 4));
                        
                        // Re-parse parts for instructions to handle '()' syntax
                        let instrParts = line.replace(/,/g, ' ').split(/\s+/).filter(Boolean);
                        
                        if (instrParts.length !== expectedArgs) {
                           errorMessage = `Invalid number of operands for ${instr}. Expected ${expectedArgs - 1}, got ${instrParts.length - 1}.`;
                        } else {
                            try {
                                if (type === 'R') {
                                    errorMessage = parseRType(instrParts, def);
                                } else if (type === 'I') {
                                    errorMessage = parseIType(instrParts, def, instr);
                                } else if (type === 'L') {
                                    errorMessage = parseLoadType(instrParts, def);
                                } else if (type === 'S') {
                                    errorMessage = parseSType(instrParts, def);
                                } else if (type === 'B') {
                                    errorMessage = parseBType(instrParts, def, labelMap, addr);
                                }
                                
                                // If errorMessage is a string, it's an error. If it's a binary string, it's success.
                                if (typeof errorMessage === 'string' && errorMessage.length > 32) {
                                    // It's an error message
                                    binaryInstr = null;
                                } else {
                                    // It's a binary string
                                    binaryInstr = errorMessage;
                                    errorMessage = null;
                                }
                            } catch (e) {
                                console.error(e);
                                errorMessage = `Internal assembler error: ${e.message}`;
                            }
                        }
                    }
                }

                if (errorMessage) {
                    reportError(errorMessage, lineNum);
                    hasError = true;
                    break;
                }

                if (binaryInstr) {
                    const hexOpcode = binToHex(binaryInstr);
                    const hexAddr = formatHex(addr.toString(16), 4); // 16-bit address
                    output.push(`${hexAddr}: ${hexOpcode}`);
                }
            }

            if (!hasError) {
                opcodeOutput.textContent = output.join('\n');
            }
        }

        
    </script>
</body>
</html>